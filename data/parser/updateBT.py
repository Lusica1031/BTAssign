# generate def files based on two def inputs
import sys, getopt

ENABLE_IO = False
ENABLE_REPLACE = True
ENABLE_MERGE = True
FORCE_NAME = True


TOP_HEIGHT = 1536
TOP_WIDTH = 128
BOT_HEIGHT = 2800
BOT_WIDTH = 380

cell_infos = {}
inst_infos = {}
inst_infos_name2alias = {}
net_infos = {}
net_infos_name2alias = {}

# Write def
def writeDef(out_def:str, design_name:str, d_x:int, d_y:int, top_comp_cnt:int, bot_comp_cnt:int, terminal_cnt:int):
    top_net_cnt = 0
    bot_net_cnt = 0

    if(ENABLE_MERGE):
        f_out_top = open(out_def+".def", 'w')
    else:
        f_out_top = open(out_def+"_top.def", 'w')
        f_out_bot = open(out_def+"_bot.def", 'w')
    
    # header
    f_out_top.write("##################################\n")
    f_out_top.write("# Generated by txt2def.py\n")
    f_out_top.write("# Design: {}\n".format(design_name))
    f_out_top.write("# Command: python txt2def.py\n")
    f_out_top.write("##################################\n")
    f_out_top.write("VERSION 5.8 ;\n")
    f_out_top.write("DIVIDERCHAR \"/\" ;\n")
    f_out_top.write("BUSBITCHARS \"[]\" ;\n")
    f_out_top.write("DESIGN {} ;\n".format(design_name))
    f_out_top.write("UNITS DISTANCE MICRONS 2000 ;\n\n")

    f_out_top.write("PROPERTYDEFINITIONS\n")
    f_out_top.write("\tCOMPONENTPIN designRuleWidth REAL ;\n")
    f_out_top.write("\tDESIGN FE_CORE_BOX_LL_X REAL 0.0000 ;\n")
    f_out_top.write("\tDESIGN FE_CORE_BOX_UR_X REAL {:.4f} ;\n".format(d_x/2000.0))
    f_out_top.write("\tDESIGN FE_CORE_BOX_LL_Y REAL 0.0000 ;\n")
    f_out_top.write("\tDESIGN FE_CORE_BOX_UR_Y REAL {:.4f} ;\n".format(d_y/2000.0))
    f_out_top.write("END PROPERTYDEFINITIONS\n\n")

    f_out_top.write("DIEAREA ( 0 0 ) ( {:d} {:d} ) ;\n\n".format(int(d_x), int(d_y)))

    if(not ENABLE_MERGE):
        f_out_bot.write("##################################\n")
        f_out_bot.write("# Generated by txt2def.py\n")
        f_out_bot.write("# Design: {}\n".format(design_name))
        f_out_bot.write("# Command: python txt2def.py\n")
        f_out_bot.write("##################################\n")
        f_out_bot.write("VERSION 5.8 ;\n")
        f_out_bot.write("DIVIDERCHAR \"/\" ;\n")
        f_out_bot.write("BUSBITCHARS \"[]\" ;\n")
        f_out_bot.write("DESIGN {} ;\n".format(design_name))
        f_out_bot.write("UNITS DISTANCE MICRONS 2000 ;\n\n")

        f_out_bot.write("PROPERTYDEFINITIONS\n")
        f_out_bot.write("\tCOMPONENTPIN designRuleWidth REAL ;\n")
        f_out_bot.write("\tDESIGN FE_CORE_BOX_LL_X REAL 0.0000 ;\n")
        f_out_bot.write("\tDESIGN FE_CORE_BOX_UR_X REAL {:.4f} ;\n".format(d_x/2000.0))
        f_out_bot.write("\tDESIGN FE_CORE_BOX_LL_Y REAL 0.0000 ;\n")
        f_out_bot.write("\tDESIGN FE_CORE_BOX_UR_Y REAL {:.4f} ;\n".format(d_y/2000.0))
        f_out_bot.write("END PROPERTYDEFINITIONS\n\n")

        f_out_bot.write("DIEAREA ( 0 0 ) ( {:d} {:d} ) ;\n\n".format(int(d_x), int(d_y)))

    # row
    total_top_cnt = int(d_y / TOP_HEIGHT)
    top_col = int(d_x / TOP_WIDTH)

    total_bot_cnt = int(d_y / BOT_HEIGHT)
    bot_col = int(d_x / BOT_WIDTH)

    for row_idx in range(total_top_cnt):
        direct = "N" if row_idx % 2 else "FS"
        f_out_top.write("ROW CORE_ROW_{} NanGate_15nm_OCL 0 {} {} DO {} BY 1 STEP {} 0\n ;\n".format(row_idx, row_idx*TOP_HEIGHT, direct, top_col, TOP_WIDTH))
    
    for row_idx in range(total_bot_cnt):
        direct = "N" if row_idx % 2 else "FS"
        if(ENABLE_MERGE):
            f_out_top.write("ROW CORE_ROW_{} FreePDK45_38x28_10R_NP_162NW_34O 0 {} {} DO {} BY 1 STEP {} 0\n ;\n".format(total_top_cnt + row_idx, row_idx*BOT_HEIGHT, direct, bot_col, BOT_WIDTH))
        else:
            f_out_bot.write("ROW CORE_ROW_{} FreePDK45_38x28_10R_NP_162NW_34O 0 {} {} DO {} BY 1 STEP {} 0\n ;\n".format(row_idx, row_idx*BOT_HEIGHT, direct, bot_col, BOT_WIDTH))

    # tracks
    f_out_top.write("\nTRACKS Y 64 DO 1884 STEP 128 LAYER MINT6 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER MINT6 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER MINT5 ;\n")
    f_out_top.write("TRACKS Y 64 DO 1884 STEP 128 LAYER MINT5 ;\n")
    f_out_top.write("TRACKS Y 64 DO 1884 STEP 128 LAYER MINT4 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER MINT4 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER MINT3 ;\n")
    f_out_top.write("TRACKS Y 64 DO 1884 STEP 128 LAYER MINT3 ;\n")
    f_out_top.write("TRACKS Y 64 DO 1884 STEP 128 LAYER MINT2 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER MINT2 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER MINT1 ;\n")
    f_out_top.write("TRACKS Y 64 DO 1884 STEP 128 LAYER MINT1 ;\n")
    f_out_top.write("TRACKS Y 64 DO 1884 STEP 128 LAYER M1 ;\n")
    f_out_top.write("TRACKS X 128 DO 1908 STEP 128 LAYER M1 ;\n\n")

    if(ENABLE_MERGE):
        # f_out_top.write("TRACKS Y 3340 DO 146 STEP 3200 LAYER metal10 ;\n")
        # f_out_top.write("TRACKS X 3550 DO 140 STEP 3360 LAYER metal10 ;\n")
        f_out_top.write("TRACKS X 1870 DO 280 STEP 1680 LAYER metal9 ;\n")
        f_out_top.write("TRACKS Y 3340 DO 146 STEP 3200 LAYER metal9 ;\n")
        f_out_top.write("TRACKS Y 1820 DO 279 STEP 1680 LAYER metal8 ;\n")
        f_out_top.write("TRACKS X 1870 DO 280 STEP 1680 LAYER metal8 ;\n")
        f_out_top.write("TRACKS X 750 DO 842 STEP 560 LAYER metal7 ;\n")
        f_out_top.write("TRACKS Y 1820 DO 279 STEP 1680 LAYER metal7 ;\n")
        f_out_top.write("TRACKS Y 700 DO 839 STEP 560 LAYER metal6 ;\n")
        f_out_top.write("TRACKS X 750 DO 842 STEP 560 LAYER metal6 ;\n")
        f_out_top.write("TRACKS X 750 DO 842 STEP 560 LAYER metal5 ;\n")
        f_out_top.write("TRACKS Y 700 DO 839 STEP 560 LAYER metal5 ;\n")
        f_out_top.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal4 ;\n")
        f_out_top.write("TRACKS X 750 DO 842 STEP 560 LAYER metal4 ;\n")
        f_out_top.write("TRACKS X 190 DO 1243 STEP 380 LAYER metal3 ;\n")
        f_out_top.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal3 ;\n")
        f_out_top.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal2 ;\n")
        f_out_top.write("TRACKS X 190 DO 1243 STEP 380 LAYER metal2 ;\n")
        f_out_top.write("TRACKS X 190 DO 1243 STEP 380 LAYER metal1 ;\n")
        f_out_top.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal1 ;\n\n")
    else:
        #f_out_bot.write("TRACKS Y 3340 DO 146 STEP 3200 LAYER metal10 ;\n")
        #f_out_bot.write("TRACKS X 3550 DO 140 STEP 3360 LAYER metal10 ;\n")
        f_out_bot.write("TRACKS X 1870 DO 280 STEP 1680 LAYER metal9 ;\n")
        f_out_bot.write("TRACKS Y 3340 DO 146 STEP 3200 LAYER metal9 ;\n")
        f_out_bot.write("TRACKS Y 1820 DO 279 STEP 1680 LAYER metal8 ;\n")
        f_out_bot.write("TRACKS X 1870 DO 280 STEP 1680 LAYER metal8 ;\n")
        f_out_bot.write("TRACKS X 750 DO 842 STEP 560 LAYER metal7 ;\n")
        f_out_bot.write("TRACKS Y 1820 DO 279 STEP 1680 LAYER metal7 ;\n")
        f_out_bot.write("TRACKS Y 700 DO 839 STEP 560 LAYER metal6 ;\n")
        f_out_bot.write("TRACKS X 750 DO 842 STEP 560 LAYER metal6 ;\n")
        f_out_bot.write("TRACKS X 750 DO 842 STEP 560 LAYER metal5 ;\n")
        f_out_bot.write("TRACKS Y 700 DO 839 STEP 560 LAYER metal5 ;\n")
        f_out_bot.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal4 ;\n")
        f_out_bot.write("TRACKS X 750 DO 842 STEP 560 LAYER metal4 ;\n")
        f_out_bot.write("TRACKS X 190 DO 1243 STEP 380 LAYER metal3 ;\n")
        f_out_bot.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal3 ;\n")
        f_out_bot.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal2 ;\n")
        f_out_bot.write("TRACKS X 190 DO 1243 STEP 380 LAYER metal2 ;\n")
        f_out_bot.write("TRACKS X 190 DO 1243 STEP 380 LAYER metal1 ;\n")
        f_out_bot.write("TRACKS Y 140 DO 1680 STEP 280 LAYER metal1 ;\n\n")

    # gcellgrid
    top_x_mid = int((d_x - 128) / 1280) + 1
    top_x_up_s = int(128 + (top_x_mid - 1)*1280)
    top_x_up_gap = int(d_x - top_x_up_s)
    
    top_y_mid = int((d_y - 64) / 1280) + 1
    top_y_up_s = int(64 + (top_y_mid - 1)*1280)
    top_y_up_gap = int(d_y - top_y_up_s)

    bot_x_mid = int((d_x - 190) / 3800) + 1
    bot_x_up_s = int(190 + (bot_x_mid - 1)*3800)
    bot_x_up_gap = int(d_x - bot_x_up_s)
    
    bot_y_mid = int((d_y - 140) / 2800) + 1
    bot_y_up_s = int(140 + (bot_y_mid - 1)*2800)
    bot_y_up_gap = int(d_y - bot_y_up_s)

    f_out_top.write("GCELLGRID X {:d} DO 2 STEP {:d} ;\n".format(top_x_up_s, top_x_up_gap))
    f_out_top.write("GCELLGRID X 128 DO {:d} STEP 1280 ;\n".format(top_x_mid))
    f_out_top.write("GCELLGRID X 0 DO 2 STEP 128 ;\n")
    f_out_top.write("GCELLGRID Y {:d} DO 2 STEP {:d} ;\n".format(top_y_up_s, top_y_up_gap))
    f_out_top.write("GCELLGRID Y 64 DO {:d} STEP 1280 ;\n".format(top_y_mid))
    f_out_top.write("GCELLGRID Y 0 DO 2 STEP 64 ;\n\n")

    if(ENABLE_MERGE):
        f_out_top.write("GCELLGRID X {:d} DO 2 STEP {:d} ;\n".format(bot_x_up_s, bot_x_up_gap))
        f_out_top.write("GCELLGRID X 190 DO {:d} STEP 3800 ;\n".format(bot_x_mid))
        f_out_top.write("GCELLGRID X 0 DO 2 STEP 190 ;\n")
        f_out_top.write("GCELLGRID Y {:d} DO 2 STEP {:d} ;\n".format(bot_y_up_s, bot_y_up_gap))
        f_out_top.write("GCELLGRID Y 140 DO {:d} STEP 2800 ;\n".format(bot_y_mid))
        f_out_top.write("GCELLGRID Y 0 DO 2 STEP 140 ;\n\n")
    else:
        f_out_bot.write("GCELLGRID X {:d} DO 2 STEP {:d} ;\n".format(bot_x_up_s, bot_x_up_gap))
        f_out_bot.write("GCELLGRID X 190 DO {:d} STEP 3800 ;\n".format(bot_x_mid))
        f_out_bot.write("GCELLGRID X 0 DO 2 STEP 190 ;\n")
        f_out_bot.write("GCELLGRID Y {:d} DO 2 STEP {:d} ;\n".format(bot_y_up_s, bot_y_up_gap))
        f_out_bot.write("GCELLGRID Y 140 DO {:d} STEP 2800 ;\n".format(bot_y_mid))
        f_out_bot.write("GCELLGRID Y 0 DO 2 STEP 140 ;\n\n")

    # components
    if(ENABLE_MERGE):
        f_out_top.write("COMPONENTS {:d} ;\n".format(top_comp_cnt + bot_comp_cnt))
    else:
        f_out_top.write("COMPONENTS {:d} ;\n".format(top_comp_cnt))
        f_out_bot.write("COMPONENTS {:d} ;\n".format(bot_comp_cnt))

    for inst_name, inst_info in inst_infos.items():
        if(FORCE_NAME):
            inst_name = inst_info["name"]
        if(inst_info["tier"]):
            # top
            row_idx = int(inst_info["loc_y"] / TOP_HEIGHT)
            direct = "N" if row_idx % 2 else "FS"
            f_out_top.write("- {} {} + PLACED ( {:d} {:d} ) {}\n ;\n".format(inst_name, inst_info["type"], inst_info["loc_x"], inst_info["loc_y"], direct))
        else:
            # bottom
            row_idx = int(inst_info["loc_y"] / BOT_HEIGHT)
            direct = "N" if row_idx % 2 else "FS"
            if(ENABLE_MERGE):
                f_out_top.write("- {} {} + PLACED ( {:d} {:d} ) {}\n ;\n".format(inst_name, inst_info["type"]+"_45", inst_info["loc_x"], inst_info["loc_y"], direct))
            else:
                f_out_bot.write("- {} {} + PLACED ( {:d} {:d} ) {}\n ;\n".format(inst_name, inst_info["type"]+"_45", inst_info["loc_x"], inst_info["loc_y"], direct))
    
    f_out_top.write("END COMPONENTS\n\n")
    if(not ENABLE_MERGE):
        f_out_bot.write("END COMPONENTS\n\n")
    
    # pin (terminal)
    f_out_top.write("PINS {:d} ;\n".format(terminal_cnt))
    if(not ENABLE_MERGE):
        f_out_bot.write("PINS {:d} ;\n".format(terminal_cnt))
    
    top_net_cnt = 0
    top_net_names = []
    top_net_alias = []
    bot_net_cnt = 0
    bot_net_names = []
    bot_net_alias = []

    for net_name, net_info in net_infos.items():
        if(FORCE_NAME):
            net_alias = net_name
            net_name = net_info["name"]
            net_infos_name2alias[net_name] = net_alias
        if(len(net_info["terminal"]) == 0):
            cell_name = net_info["pins"][0].rsplit('/')[0]
            if(FORCE_NAME):
                cell_name = inst_infos_name2alias[cell_name]
            if(inst_infos[cell_name]["tier"]):
                # top
                top_net_cnt += 1
                top_net_names.append(net_name)
                if(FORCE_NAME):
                    top_net_alias.append(net_alias)
            else:
                # bottom
                bot_net_cnt += 1
                bot_net_names.append(net_name)
                if(FORCE_NAME):
                    bot_net_alias.append(net_alias)
        else:
            top_net_cnt += 1
            bot_net_cnt += 1
            top_net_names.append(net_name)
            bot_net_names.append(net_name)
            if(FORCE_NAME):
                top_net_alias.append(net_alias)
                bot_net_alias.append(net_alias)

            f_out_top.write("- {} + NET {} + DIRECTION INPUT + USE SIGNAL\n".format(net_info["terminal"]["name"], net_name))
            f_out_top.write("  + LAYER MINT6 ( -500 -500 ) ( 500 500 )\n")
            f_out_top.write("  + PLACED ( {:d} {:d} ) N ;\n".format(net_info["terminal"]["loc_x"], net_info["terminal"]["loc_y"]))

            if(not ENABLE_MERGE):
                f_out_bot.write("- {} + NET {} + DIRECTION INPUT + USE SIGNAL\n".format(net_info["terminal"]["name"], net_name))
                f_out_bot.write("  + LAYER metal10 ( -500 -500 ) ( 500 500 )\n")
                f_out_bot.write("  + PLACED ( {:d} {:d} ) N ;\n".format(net_info["terminal"]["loc_x"], net_info["terminal"]["loc_y"]))

    f_out_top.write("END PINS\n\n")
    if(not ENABLE_MERGE):
        f_out_bot.write("END PINS\n\n")
        
    # nets
    if(ENABLE_MERGE):
        f_out_top.write("NETS {} ;\n".format(top_net_cnt + bot_net_cnt))
    else:
        f_out_top.write("NETS {} ;\n".format(top_net_cnt))
        f_out_bot.write("NETS {} ;\n".format(bot_net_cnt))

    if(FORCE_NAME):
        for net_name, net_alias in zip(top_net_names, top_net_alias):
            f_out_top.write("- {}\n".format(net_name))
            if(len(net_infos[net_alias]["terminal"]) != 0):
                f_out_top.write("  ( PIN {} )\n".format(net_infos[net_alias]["terminal"]["name"]))
            for pin_name in net_infos[net_alias]["pins"]:
                cell_name = pin_name.rsplit("/")[0]
                pin_name = pin_name.rsplit("/")[1]
                if(inst_infos[inst_infos_name2alias[cell_name]]["tier"]):
                    f_out_top.write("  ( {} {} )\n".format(cell_name, pin_name))
            f_out_top.write(" ;\n")
        
        updateBT("./ethmac_bt.txt")
    else:
        for net_name in top_net_names:
            f_out_top.write("- {}\n".format(net_name))
            if(len(net_infos[net_name]["terminal"]) != 0):
                f_out_top.write("  ( PIN {} )\n".format(net_infos[net_name]["terminal"]["name"]))
            for pin_name in net_infos[net_name]["pins"]:
                cell_name = pin_name.rsplit("/")[0]
                pin_name = pin_name.rsplit("/")[1]
                if(inst_infos[cell_name]["tier"]):
                    f_out_top.write("  ( {} {} )\n".format(cell_name, pin_name))
            f_out_top.write(" ;\n")
    
    if(ENABLE_MERGE):
        if(FORCE_NAME):
            for net_name, net_alias in zip(bot_net_names, bot_net_alias):
                f_out_top.write("- {}\n".format(net_name))
                if(len(net_infos[net_alias]["terminal"]) != 0):
                    f_out_top.write("  ( PIN {} )\n".format(net_infos[net_alias]["terminal"]["name"]))
                for pin_name in net_infos[net_alias]["pins"]:
                    cell_name = pin_name.rsplit("/")[0]
                    pin_name = pin_name.rsplit("/")[1]
                    if(not inst_infos[inst_infos_name2alias[cell_name]]["tier"]):
                        f_out_top.write("  ( {} {} )\n".format(cell_name, pin_name))
                f_out_top.write(" ;\n")
        else:
            for net_name in bot_net_names:
                f_out_top.write("- {}\n".format(net_name))
                if(len(net_infos[net_name]["terminal"]) != 0):
                    f_out_top.write("  ( PIN {} )\n".format(net_infos[net_name]["terminal"]["name"]))
                for pin_name in net_infos[net_name]["pins"]:
                    cell_name = pin_name.rsplit("/")[0]
                    pin_name = pin_name.rsplit("/")[1]
                    if(not inst_infos[cell_name]["tier"]):
                        f_out_top.write("  ( {} {} )\n".format(cell_name, pin_name))
                f_out_top.write(" ;\n")
    else:
        if(FORCE_NAME):
            for net_name, net_alias in zip(bot_net_names, bot_net_alias):
                f_out_bot.write("- {}\n".format(net_name))
                if(len(net_infos[net_alias]["terminal"]) != 0):
                    f_out_bot.write("  ( PIN {} )\n".format(net_infos[net_alias]["terminal"]["name"]))
                for pin_name in net_infos[net_alias]["pins"]:
                    cell_name = pin_name.rsplit("/")[0]
                    pin_name = pin_name.rsplit("/")[1]
                    if(inst_infos[inst_infos_name2alias[cell_name]]["tier"] == 0):
                        f_out_bot.write("  ( {} {} )\n".format(cell_name, pin_name))
                f_out_bot.write(" ;\n")
        else:
            for net_name in bot_net_names:
                f_out_bot.write("- {}\n".format(net_name))
                if(len(net_infos[net_name]["terminal"]) != 0):
                    f_out_bot.write("  ( PIN {} )\n".format(net_infos[net_name]["terminal"]["name"]))
                for pin_name in net_infos[net_name]["pins"]:
                    cell_name = pin_name.rsplit("/")[0]
                    pin_name = pin_name.rsplit("/")[1]
                    if(inst_infos[cell_name]["tier"] == 0):
                        f_out_bot.write("  ( {} {} )\n".format(cell_name, pin_name))
                f_out_bot.write(" ;\n")

    f_out_top.write("END NETS\n\n")
    f_out_top.write("END DESIGN\n")
    if(not ENABLE_MERGE):
        f_out_bot.write("END NETS\n\n")
        f_out_bot.write("END DESIGN\n")

# parse cell type infos
def parseLef(file_name:str, tech_name:str): # tech_name is TA TB
    cell_flag = False
    pin_flag = False
    MC_cnt = 1
    P_cnt = 1

    cell_infos[tech_name] = {}
    with open(file_name, 'r') as f_in:
        line = f_in.readline()
        cnt = 1
        while line:
            print("Line {}: {}".format(cnt, line.strip()))
            lines = line.split()
            if(cell_flag):
                
                if ("SIZE" in line):
                    x = lines[1]
                    y = lines[3]
                    if(tech_name == "TA"):
                        cell_infos[tech_name][cell_name] = {"size_x": int(float(x) * 2000), 
                                                            "size_y": int(float(y) * 2000),
                                                            "pins":{},
                                                            "alias": "MC"+str(MC_cnt)}
                if ("PIN" in line):
                    pin_flag = True
                    pin_name = lines[1]
                
                if ("DIRECTION" in line and pin_flag):
                    # donot consider INOUT pin
                    if ("INPUT" not in line and "OUTPUT" not in line):
                        pin_flag = False
                        pin_name = ""
                
                if(pin_flag and " RECT " in line):
                    # TODO: take multiple rect into consideration
                    x_l = float(lines[1])
                    y_l = float(lines[2])
                    x_r = float(lines[3])
                    y_r = float(lines[4])
                    pin_x = (x_l + x_r) / 2.0
                    pin_y = (y_l + y_r) / 2.0
                    if(tech_name == "TA"):
                        cell_infos[tech_name][cell_name]["pins"]["P"+str(P_cnt)] = {"loc_x": int(int(pin_x * 2000) / 2) * 2, "loc_y": int(int(pin_y * 2000) / 2) * 2, "name": pin_name}
                    pin_flag = False
                    P_cnt += 1

                if(cell_name in line and "END" in line):
                    if(len(cell_infos[tech_name][cell_name]["pins"]) < 2):
                        del cell_infos[tech_name][cell_name]
                        MC_cnt -= 1
                    cell_flag = False
                    MC_cnt += 1

            else:
                if ("MACRO" in line):
                    cell_flag = True
                    cell_name = line.split()[1]
                    P_cnt = 1
            
            line = f_in.readline()
            cnt += 1

# parse connection infos and instance infos
def parseDef(file_name:str):
    comp_flag = False
    pins_flag = False
    nets_flag = False
    net_flag = False
    clk_flag = True

    C_cnt = 1
    N_cnt = 1

    with open(file_name, 'r') as f_in:
        line = f_in.readline()
        cnt = 1
        while line:
            print("Line {}: {}".format(cnt, line.strip()))

            if("DIEAREA" in line):
                lines = line.split()
                d_x = float(lines[6])
                d_y = float(lines[7])
            elif("COMPONENTS" in line):
                comp_flag = "END" not in line
            elif("NETS" in line):
                nets_flag = "END" not in line
            elif("PINS" in line):
                pins_flag = "END" not in line
            elif(comp_flag):
                if("-" in line):
                    lines = line.split()
                    if(ENABLE_REPLACE):
                        lines[1] = lines[1].replace('/','_')
                        lines[1] = lines[1].replace('\[', '_')
                        lines[1] = lines[1].replace('\]', '_')
                    inst_infos["C"+str(C_cnt)] = {"type":lines[2], "tier": 0, "loc_x": -1, "loc_y": -1,
                                            "name":lines[1]}
                    inst_infos_name2alias[lines[1]] = "C"+str(C_cnt)
                    C_cnt += 1

            elif(ENABLE_IO):
                if(pins_flag):
                    if("-" in line):
                        lines = line.split()
                        # TODO: enable IO
                        assert("INPUT" not in line and "OUTPUT" not in line)
                        if("INPUT" in line):
                            inst_infos["C"+str(C_cnt)] = {"type":"PI", "tier": 0, "loc_x": -1, "loc_y": -1,
                                                    "name":lines[1]}
                            inst_infos_name2alias[lines[1]] = "C"+str(C_cnt)
                            C_cnt += 1

                        elif("OUTPUT" in line):
                            inst_infos["C"+str(C_cnt)] = {"type":"PO", "tier": 0, "loc_x": -1, "loc_y": -1,
                                                    "name":lines[1]}
                            inst_infos_name2alias[lines[1]] = "C"+str(C_cnt)
                            C_cnt += 1
    
            elif(nets_flag):
                if("-" in line):
                    if(clk_flag):
                        clk_flag = False
                    else:
                        lines = line.split()
                        net_flag = True
                        if(ENABLE_REPLACE):
                            lines[1] = lines[1].replace('/', '_')
                            lines[1] = lines[1].replace('\[', '_')
                            lines[1] = lines[1].replace('\]', '_')
                        net_name = lines[1]
                        pin_vec = []
                elif(";" in line and net_flag):
                    net_flag = False
                    if(len(pin_vec) != 0):
                        if(ENABLE_REPLACE):
                            net_name = net_name.replace('/', '_')
                            net_name = net_name.replace('[', '_')
                            net_name = net_name.replace(']', '_')
                        net_infos["N"+str(N_cnt)] = { "pins": pin_vec, "name": net_name, "terminal": {}}
                        N_cnt += 1
                    net_name = ""
                    pin_vec = []
                elif(net_flag):
                    lines = line.split(") (")
                    lines[0] = lines[0].split("(")[1]
                    lines[-1] = lines[-1].split(")")[0]
                    for p_info in lines:
                        p_infos = p_info.split()
                        assert(len(p_infos) == 2)
                        if(p_infos[0] == "PIN"):
                            if(ENABLE_IO):
                                pin_vec.append(p_infos[1])
                            else:
                                continue
                        else:
                            if(ENABLE_REPLACE):
                                p_infos[0] = p_infos[0].replace('/', '_')
                                p_infos[0] = p_infos[0].replace('\[', '_')
                                p_infos[0] = p_infos[0].replace('\]', '_')
                            pin_vec.append(p_infos[0]+'/'+p_infos[1])

            line = f_in.readline()
            cnt += 1
        return d_x, d_y

# parse partitioning infos
def parseTxt(in_txt: str):
    with open(in_txt, 'r') as f_in:
        top_flag = False
        bottom_flag = False
        terminal_flag = False

        line = f_in.readline()
        cnt = 1
        terminal_cnt = 0
        while line:
            # print("Line {}: {}".format(cnt, line.strip()))
            if("TopDiePlacement" in line):
                top_flag = True
                bottom_flag = False
                terminal_flag = False
                lines = line.split()
                top_comp_cnt = int(lines[1])
            elif("BottomDiePlacement" in line):
                top_flag = False
                bottom_flag = True
                terminal_flag = False
                lines = line.split()
                bot_comp_cnt = int(lines[1])
            elif("NumTerminals" in line):
                top_flag = False
                bottom_flag = False
                terminal_flag = True
                terminal_cnt = 0
            elif(top_flag):
                if("Inst" in line):
                    lines = line.split()
                    inst_infos[lines[1]]["tier"] = 1
                    inst_infos[lines[1]]["loc_x"] = int(int(lines[2]) / 2) * 2
                    inst_infos[lines[1]]["loc_y"] = int(int(lines[3]) / 2) * 2
            elif(bottom_flag):
                if("Inst" in line):
                    lines = line.split()
                    inst_infos[lines[1]]["tier"] = 0
                    inst_infos[lines[1]]["loc_x"] = int(int(lines[2]) / 2) * 2
                    inst_infos[lines[1]]["loc_y"] = int(int(lines[3]) / 2) * 2
            elif(terminal_flag):
                if("Terminal" in line):
                    lines = line.split()
                    net_infos[lines[1]]["terminal"] = {"name": "T"+str(terminal_cnt), "loc_x": int(int(lines[2]) / 2) * 2, "loc_y": int(int(lines[3]) / 2) * 2}
                    terminal_cnt += 1

            line = f_in.readline()
            cnt += 1

    return top_comp_cnt, bot_comp_cnt, terminal_cnt

def readWAlias(design_name: str, top_name: str, bin_name: str):
    in_lef = "./pdks/Nangate15/back_end/lef/NanGate_15nm_OCL.macro.lef"
    in_def = "./datasets/"+design_name+"/Nangate15/"+top_name+".mapped.def"
    in_txt = "./place/output/"+bin_name+"/"+design_name+".output"

    print("Start Parsing {} {} {}\n".format(in_lef, in_def, in_txt))

    parseLef(in_lef, "TA")
    d_x, d_y = parseDef(in_def)
    top_comp_cnt, bot_comp_cnt, terminal_cnt = parseTxt(in_txt)

    return d_x, d_y, top_comp_cnt, bot_comp_cnt, terminal_cnt

# no alias
def readWoAlias(design_name: str, top_name: str, bin_name: str):

    in_def = "./datasets/"+design_name+"/Nangate15/"+top_name+".mapped.def"
    in_txt = "./place/output/"+binary_name+"/"+design_name+".output"

    print("Start Parsing {} {}\n".format(in_def, in_txt))

    comp_flag = False
    nets_flag = False
    pins_flag = False

    d_x = 0
    d_y = 0
    top_comp_cnt = 0
    bot_comp_cnt = 0
    terminal_cnt = 0

    C_cnt = 1

    with open(in_def, 'r') as f_in:
        line = f_in.readline()
        cnt = 1
        while line:
            # print("Line {}: {}".format(cnt, line.strip()))

            if("DIEAREA" in line):
                lines = line.split()
                d_x = float(lines[6])
                d_y = float(lines[7])
            elif("COMPONENTS" in line):
                comp_flag = "END" not in line
            elif("NETS" in line):
                nets_flag = "END" not in line
            elif("PINS" in line):
                pins_flag = "END" not in line
            elif(comp_flag):
                if("-" in line):
                    lines = line.split()
                    if(ENABLE_REPLACE):
                        lines[1] = lines[1].replace('/','_')
                        lines[1] = lines[1].replace('\[', '_')
                        lines[1] = lines[1].replace('\]', '_')

                    inst_infos[lines[1]] = {"type":lines[2],
                                            "tier": 0, "loc_x": -1, "loc_y": -1,
                                            "alias":"C"+str(C_cnt)}
                    C_cnt += 1

                    # inst_infos[lines[1]] = {"type": lines[2], "tier": 0, "loc_x": -1, "loc_y": -1} # tier 0: bottom 1: top
            elif(ENABLE_IO):
                if(pins_flag):
                    if("-" in line):
                        lines = line.split()
                        if("INPUT" in line):
                            inst_infos[lines[1]] = {"type": "PI", "tier": 0, "loc_x": -1, "loc_y": -1, "alias":"C"+str(C_cnt)} # tier 0: bottom 1: top
                            C_cnt += 1
                        elif("OUTPUT" in line):
                            inst_infos[lines[1]] = {"type": "PO", "tier": 0, "loc_x": -1, "loc_y": -1, "alias":"C"+str(C_cnt)} # tier 0: bottom 1: top
                            C_cnt += 1
            elif(nets_flag):
                if("-" in line):
                    lines = line.split()
                    net_flag = True
                    if(ENABLE_REPLACE):
                        lines[1] = lines[1].replace('/', '_')
                        lines[1] = lines[1].replace('\[', '_')
                        lines[1] = lines[1].replace('\]', '_')
                    net_name = lines[1]
                    pin_vec = []
                elif(";" in line):
                    net_flag = False
                    if(len(pin_vec) != 0):
                        net_infos[net_name] = {"pins": pin_vec, "terminal": {}}
                    net_name = ""
                    pin_vec = []
                elif(net_flag):
                    lines = line.split(") (")
                    lines[0] = lines[0].split("(")[1]
                    lines[-1] = lines[-1].split(")")[0]
                    for p_info in lines:
                        p_infos = p_info.split()
                        assert(len(p_infos) == 2)
                        if(p_infos[0] == "PIN"):
                            if(ENABLE_IO):
                                pin_vec.append(p_infos[1])
                            else:
                                continue
                        else:
                            if(ENABLE_REPLACE):
                                p_infos[0] = p_infos[0].replace('/', '_')
                                p_infos[0] = p_infos[0].replace('\[', '_')
                                p_infos[0] = p_infos[0].replace('\]', '_')
                            pin_vec.append(p_infos[0]+'/'+p_infos[1])

            line = f_in.readline()
            cnt += 1

    with open(in_txt, 'r') as f_in:
        top_flag = False
        bottom_flag = False
        terminal_flag = False

        line = f_in.readline()
        cnt = 1
        terminal_cnt = 0
        while line:
            # print("Line {}: {}".format(cnt, line.strip()))
            
            if("TopDiePlacement" in line):
                top_flag = True
                bottom_flag = False
                terminal_flag = False
                lines = line.split()
                top_comp_cnt = int(lines[1])
            elif("BottomDiePlacement" in line):
                top_flag = False
                bottom_flag = True
                terminal_flag = False
                lines = line.split()
                bot_comp_cnt = int(lines[1])
            elif("NumTerminals" in line):
                top_flag = False
                bottom_flag = False
                terminal_flag = True
                terminal_cnt = 0
            elif(top_flag):
                if("Inst" in line):
                    lines = line.split()
                    inst_infos[lines[1]]["tier"] = 1
                    inst_infos[lines[1]]["loc_x"] = int(int(lines[2]) / 2) * 2
                    inst_infos[lines[1]]["loc_y"] = int(int(lines[3]) / 2) * 2
            elif(bottom_flag):
                if("Inst" in line):
                    lines = line.split()
                    inst_infos[lines[1]]["tier"] = 0
                    inst_infos[lines[1]]["loc_x"] = int(int(lines[2]) / 2) * 2
                    inst_infos[lines[1]]["loc_y"] = int(int(lines[3]) / 2) * 2
            elif(terminal_flag):
                if("Terminal" in line):
                    lines = line.split()
                    net_infos[lines[1]]["terminal"] = {"name": "T"+str(terminal_cnt), "loc_x": int(int(lines[2]) / 2) * 2, "loc_y": int(int(lines[3]) / 2) * 2}
                    terminal_cnt += 1

            line = f_in.readline()
            cnt += 1

    net_infos.pop() # delete clock net
    return d_x, d_y, top_comp_cnt, bot_comp_cnt, terminal_cnt

def diesize(x:int, y:int):
    lcm_y = 268800
    lcm_x = 12160
    target_area = 0.7 * x * y # 2 / sqrt(5)
    new_x = 0
    new_y = 0

    for y_mul in range(1,100):
        new_y = y_mul * lcm_y
        new_x = target_area / new_y
        if(abs(new_x - new_y)/new_y < 0.8 and abs(new_x - new_y)/new_x < 0.8):
            break

    d_x = int(int(new_x) / 2) * 2
    d_y = int(int(new_y) / 2) * 2

    return d_x, d_y

def updateBT(in_txt:str, out_txt:str):
     with open(in_txt, 'r') as f_in:
        with open(out_txt, 'w') as f_out:
            line = f_in.readline()
            while line:
                infos = line.split()
                f_out.write("Terminal {} {} {}\n".format(net_infos_name2alias[infos[1]], infos[2], infos[3]))
                line = f_in.readline()
            
def main(argv):
    design_name = ""
    top_name = ""
    bin_name = ""
    try:
        opts, args = getopt.getopt(argv,"hb:n:t:",["bin=","name=","top="])
    except getopt.GetoptError:
        print('python lef2txt.py -b <binary_name> -n <design_name> -t <top>')
        sys.exit(2)

    for opt, arg in opts:
        if opt == '-h':
            print('python lef2txt.py -b <binary_name> -n <design_name> -t <top>')
            sys.exit()
        elif opt in ("-b", "--bin"):
            bin_name = arg
        elif opt in ("-n", "--name"):
            design_name = arg
        elif opt in ("-t", "--top"):
            top_name = arg
    
    def_out_path = "./place/output/"+bin_name+"/"+design_name

    if(FORCE_NAME):
        d_x, d_y, top_comp_cnt, bot_comp_cnt, terminal_cnt = readWAlias(design_name, top_name, bin_name)
    else:
        d_x, d_y, top_comp_cnt, bot_comp_cnt, terminal_cnt = readWoAlias(design_name, top_name, bin_name)
    
    print("Finish Parsing\n")

    d_x, d_y = diesize(d_x, d_y)
    
    print("=====================================\n")
    print("Die Area: {} {}\n".format(d_x, d_y))
    print("Components: Top - {} Bottom - {}\n".format(top_comp_cnt, bot_comp_cnt))
    print("Terminal: {}".format(terminal_cnt))
    print("=====================================\n")

    if(ENABLE_MERGE):
        print("Start Output to {}\n".format(def_out_path+".def"))
    else: 
        print("Start Output to {}\n".format(def_out_path+"_top.def / _bot.def"))

    writeDef(def_out_path, design_name, d_x, d_y, top_comp_cnt, bot_comp_cnt, terminal_cnt)
    print("Finish Output\n")

if __name__ == "__main__":
   main(sys.argv[1:])
